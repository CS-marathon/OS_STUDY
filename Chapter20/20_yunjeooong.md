# 20장 페이징: 더 작은 테이블

## 1. 문제 정의

- **선형(배열 기반) 페이지 테이블**은 주소 공간의 모든 가상 페이지에 대응하는 PTE를 **연속**으로 저장.
- 32비트·4KB 페이지 기준: VPN=20비트 → 2^20 entries × 4B ≈ **4MB/프로세스** 
- 프로세스 100개 → 400MB 메모리 오버헤드!

**핵심 질문**: 페이지 테이블을 **어떻게 더 작게** 만들 수 있을까?

---

## 2. 20.1 간단한 해법: 더 큰 페이지

- **기법**: 페이지 크기를 4KB→16KB로 4배 증가 → VPN 비트 20→18, PTE entries 2^18 → 테이블 크기 **1MB**로 감소

  > `테이블 크기 ∝ 1 / 페이지 크기`

- **장점**: 구조·알고리즘 수정 없이 간단한 크기 변경만으로 즉시 효과
- **단점**: **내부 단편화(internal fragmentation)** 증가
    - 페이지 내부 낭비 공간 ↑ → 메모리 활용도 저하
    - 특히 작은 버퍼·객체 할당 시 무시 못할 손실

---

## 3. 20.2 하이브리드 접근: 페이징 + 세그멘트

- **아이디어**: 세그멘테이션 단위로 페이지 테이블을 분리 → **프로세스 전체**가 아닌 **세그멘트별**로 테이블 유지

### 3.1 구조
1. **세그멘트 레지스터**: 각 세그멘트의 페이지 테이블 시작 주소(`Base[SN]`)와 크기(`Limit[SN]`) 보관
2. 가상 주소 분해: 상위 비트 SN(00~11)→세그멘트 선택, 중간 비트 VPN→페이지 인덱스, 하위 비트 offset
3. **PTE 주소 계산**:
   ```
   SN = (VA & SEG_MASK) >> SN_SHIFT
   VPN = (VA & VPN_MASK) >> VPN_SHIFT
   AddrPTE = Base[SN] + VPN * sizeof(PTE)
   ```

### 3.2 장/단점
- **장점**: 사용되는 세그멘트(코드·힙·스택)에 한정해 테이블 할당 → 미사용 세그멘트의 낭비 제거
- **단점**:
    - 여전히 **외부 단편화** 유발(세그멘트 크기 가변)
    - 세그멘트별 테이블 위치·크기 관리 복잡
    - 힙처럼 sparsely used 영역엔 낭비 여전

---

## 4. 20.3 멀티 레벨 페이지 테이블

**세그멘테이션 없이** 테이블 크기를 줄이는 대표 기법. 선형 테이블을 **트리**로 변환합니다.

### 4.1 개념
1. **페이지 디렉터리**(1단계): 각 entry(PDE)가 한 페이지(4KB) 단위의 페이지 테이블 존재 여부·위치 저장
2. **페이지 테이블**(2단계): 실제 PTE를 갖는 페이지들만 메모리에 배치

```pseudo
PDIndex = (VPN >> PT_BITS)
PDE = MEM[PDBR + PDIndex * sizeof(PDE)]
if !PDE.valid: SIGSEGV
PTIndex = VPN & ((1<<PT_BITS)-1)
PTE = MEM[(PDE.PFN<<SHIFT) + PTIndex*sizeof(PTE)]
```

- **주소 분할**: `VPN = PDIndex | PTIndex`
- **다단계**: 3단계 이상으로 확장 가능(대규모 주소 공간 대응)

### 4.2 장점
- 사용된 **주소 공간**에 비례해 테이블 페이지만 할당
- 메모리 조각화 최소화: 각 테이블 페이지를 **개별적으로** 할당·회수

### 4.3 단점
- **TLB 미스** 시, 디렉터리+테이블 두 번 **메모리 접근** → 변환 비용 2배 증가
- 구현·하드웨어 복잡도↑

---

## 5. 20.4 역 페이지 테이블 (Inverted PT)

- **아이디어**: 프로세스당 다수의 테이블 대신 **시스템 공용** 하나의 테이블 유지
- **테이블 항목**: 각 물리 프레임 → (PID, VPN, prot, 등) 저장
- **변환**: 해시/연결 리스트로 물리→가상 매핑 탐색

### 장/단점
- **장점**: 총 테이블 크기 ∝ 물리 프레임 수(보통 작음)
- **단점**: 해시 충돌·탐색·동기화 오버헤드, 공유 페이지 처리 복잡

---

## 6. 20.5 페이지 테이블 디스크 스와핑

- 대형 테이블도 **메모리에 상주**하지 못할 수 있음
- **커널 가상 메모리**에 페이지 테이블 배치 → **디스크 스와핑** 지원
- 예: VAX/VMS에서 페이지 테이블 스와핑 기법 사용 

---

## 7. 요약 및 결론

- 페이지 테이블 크기 문제는 **시간/공간 절충**의 전형적 사례
- **더 큰 페이지**, **하이브리드**, **멀티레벨**, **역 테이블**, **스와핑** 등 다양한 기법 존재
- 실제 시스템은 워크로드·메모리 규모·하드웨어 지원 수준에 맞춰 적절히 조합하여 사용해야 합니다.


