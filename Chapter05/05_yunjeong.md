## process API
### 프로세스 제어 API (System Call)

운영체제는 사용자 애플리케이션에게 직접 하드웨어에 접근하거나 시스템 자원에 무분별하게 접근하지 못하도록 제한을 둔다.  
이에 따라, **프로세스의 생성, 실행, 종료 등의 제어 작업은 System Call을 통해서만 수행**할 수 있다.

### 시스템 콜과 Privileged Instruction

- **Privileged Instruction**  
  프로세스 생성, 실행, 종료 등 시스템 자원을 직접 다루는 명령.  
  일반 사용자 애플리케이션이 직접 수행할 경우 시스템에 문제를 일으킬 수 있으므로 **운영체제만 실행 가능**하다.

- **System Call**  
  애플리케이션이 **운영체제에게 요청을 전달하는 인터페이스**로,  
  Privileged Instruction을 **우회적으로 수행**할 수 있도록 한다.

- **동작 흐름**
    1. 애플리케이션이 System Call 호출
    2. `trap` 발생 → **Kernel Mode로 진입**
    3. 시스템 콜 실행
    4. `return-from-trap` → **User Mode로 복귀**

---

### 주요 프로세스 제어 시스템 콜

#### 1. `fork()` - 프로세스 생성

- 새로운 자식 프로세스를 생성한다.
- 자식 프로세스는 부모 프로세스의 **주소 공간을 복사**하여 별도의 메모리 공간을 갖는다.
- 부모와 자식은 **각자 독립된 프로세스**로 동작하며, `fork()` 호출 이후의 라인부터 실행을 이어간다.
- 반환값:
    - 자식 프로세스: `0`
    - 부모 프로세스: 자식 프로세스의 PID(양의 정수)

- 자식 프로세스가 상속받는 항목:
    - 파일 디스크립터(file descriptor)
    - 시그널 처리 설정
    - 환경 변수 등

- 예시 코드:
  ```c
  int main(char[] argv) {
      printf("Start\n");
      int code = fork();
      if (code == 0) printf("Child Process\n");
      else printf("Parent Process\n");
      printf("End\n");
  }

  // 출력 결과 (스케줄링에 따라 순서는 바뀔 수 있음)
  Start
  Parent Process
  Child Process
  End
  End 
  ```


#### 2. `exec()` - 프로그램 실행

- 기존 프로세스의 주소 공간(코드, 데이터, 힙, 스택 등)을 제거하고,
- 새로운 프로그램의 코드로 해당 공간을 덮어쓴다.
- `fork()` 이후 자식 프로세스에서 `exec()`를 호출해 다른 프로그램을 실행할 때 주로 사용된다.
- 실행 방식:
    - 새로운 프로그램의 실행 파일을 메모리에 로드
    - 코드 영역, 정적 데이터 영역을 초기화
    - 힙, 스택 등도 초기화됨

---

#### 3. `wait()` - 자식 프로세스 대기

- 부모 프로세스가 자식 프로세스가 종료될 때까지 대기하게 한다.
- 자식이 종료되면 `wait()`이 반환되며 부모 프로세스는 실행을 재개한다.
- 자식의 종료 상태를 수거해 좀비 프로세스(Zombie Process) 생성을 방지한다.

- 예시 코드:

  ```c
  int main(char[] argv) {
      printf("Start\n");
      int code = fork();
      if (code == 0) printf("Child Process\n");
      else {
          wait();  // 자식 프로세스 종료 대기
          printf("Parent Process\n");
      }
      printf("End\n");
  }

  // 출력 예시:
  Start
  Child Process
  End
  Parent Process
  End
   ```

### 좀비 프로세스 (Zombie Process)

- 프로세스가 종료되었지만, 부모 프로세스가 종료 상태를 회수하지 않아
  커널의 프로세스 테이블에 정보가 남아 있는 상태
- 시스템 자원을 계속 점유하므로, 정리되지 않으면 자원 누수가 발생할 수 있음
- `wait()` 또는 `waitpid()` 시스템 콜을 통해 부모가 자식의 종료 상태를 수거하면
  좀비 상태는 제거된다

---
### 4. 왜 `fork()` 후 `exec()` 구조를 사용하는가?

- UNIX 환경에서 쉘(shell)을 구현하기 위해 `fork()`와 `exec()`를 분리해서 사용
- `exec()`를 호출하기 전에 환경 설정(예: 입출력 리다이렉션, 파이프 연결 등)을 수행해야 하기 때문


```bash
echo hello | grep "h" > out
// echo 프로세스는 "hello"를 파이프에 출력해야함
// grep 프로세스는 파이프로 부터 입력을 받고 out이라는 파일에 출력해야함
```

---

### 운영체제가 프로세스를 실행하는 과정

운영체제는 새로운 프로그램이 실행되도록 하기 위해, 아래와 같은 **프로세스 생성 및 실행 단계**를 수행한다.  
프로그램을 더블 클릭하거나, 터미널에서 명령어를 입력하는 등의 동작이 발생하면 OS는 내부적으로 `fork()` 또는 그에 준하는 API를 호출하여 프로세스를 생성하고 실행 준비를 시작한다.

---

#### 1. 프로세스 생성 요청 및 등록

- 사용자가 프로그램을 실행하면, 운영체제는 프로세스 생성 API를 호출함  
  예: `fork()`, `CreateProcess()` 등
- 새로운 프로세스를 **프로세스 리스트(Process List)** 에 등록하여 관리 시작

---

#### 2. 주소 공간 할당 및 코드/데이터 로드

- 프로세스에 **고유한 가상 주소 공간(Address Space)** 을 할당
- 디스크에 저장된 **실행 파일(Executable File)** 을 읽어,
    - 코드(Code)와 정적 데이터(Static Data)를 메모리의 **코드 영역(Text/Data Section)** 에 로드
- 최근에는 **지연 초기화(Lazy Loading)** 기술을 사용하여,
    - 처음부터 전체를 로드하지 않고, **필요한 코드와 데이터를 실행 시점에 나눠서 로드**함

---

#### 3. 스택 및 힙 메모리 예약

- 메모리 내에서 **스택(Stack)** 과 **힙(Heap)** 용 영역을 설정
    - **스택(Stack)**: 지역 변수, 함수 파라미터, 반환 주소 저장
    - **힙(Heap)**: 실행 중 동적으로 할당되는 데이터 저장 (`malloc`, `new` 등)

---

#### 4. 입출력 초기화

- 표준 입출력 시스템 (stdin, stdout, stderr 등)을 초기화
- 필요한 I/O 자원 및 파일 디스크립터를 설정하여 **프로세스가 기본적인 입출력을 수행할 수 있도록 준비**

---

#### 5. 프로그램 진입점(main) 설정

- 프로그램의 시작 지점인 `main()` 함수의 주소로 **Program Counter(PC)** 를 설정
- 운영체제는 프로세스에게 **CPU 제어권을 넘김**
- 이 시점부터 **프로세스가 사용자 프로그램을 직접 실행**하게 된다

---

### 전체 요약 흐름

| 단계 | 설명 |
|------|------|
| 1. 프로세스 생성 요청 | 프로그램 실행 요청 → OS가 프로세스 생성 API 호출 |
| 2. 주소 공간 및 코드 로드 | 메모리 공간 할당 후, 실행 파일을 코드 영역에 로드 |
| 3. 메모리 영역 예약 | Stack, Heap 영역 예약 및 초기화 |
| 4. 입출력 초기화 | 표준 입출력 및 파일 디스크립터 설정 |
| 5. 실행 시작 | `main()`으로 진입, CPU 제어권 전달 후 프로그램 실행 |
