# 락

## 1. 락 : 기본 개념

```c
lock(&mutex);
balance = balance + 1;
unlock(&mutex);
```

락(lock_t mutex)을 이용해 동시에 여러 스레드가 임계 영역에 들어오지 못하게 보호한다.

### (1) 락의 상태

- 사용 가능(Available): 어떤 스레드도 락을 획득하지 않은 상태 (unlocked) <br>
- 사용 중(Acquired): 한 스레드가 락을 획득하고 임계 영역을 실행 중인 상태 (locked) <br>

### (2) lock()과 unlock()

- lock(): 락이 사용 가능하면 즉시 획득하고 임계 영역에 진입한다.
    - 진입한 스레드를 락 소유자라고 한다.
    - 락이 사용 중이면, 다른 스레드는 대기(blocked).
- unlock(): 락을 해제하고, 대기 중인 스레드가 있다면 그 중 하나가 락을 획득한다.

## 2. pthread 락

```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_lock(&lock);
balance = balance + 1;
pthread_mutex_unlock(&lock);
```

pthread_mutex_lock()과 pthread_mutex_unlock()을 사용해 임계 영역 보호. <br>
변수에 따라 다른 락을 사용 가능
-> 거친 락(coarse-grained) : 하나의 락이 임의의 임계 영역에 진입할 때마다 사용
-> 세밀한 락(fine-grained lock) : 서로 다른 데이터와 자료 구조를 보호하기 위해 여러 락을 사용하여 한 번에 여러 스레드가 서로 다른 락으로 보호된 코드내에 각자가 진입이 가능하도록 하는 방법

## 3. 락 구현

락 구현에는 하드웨어와 운영체제의 지원이 필요 <br>
CPU는 락 구현을 위한 원자적 명령어(atomic instruction) 제공

운영체제는 락을 효과적으로 사용하기 위한 기본 기능 제공

## 4. 락의 평가

(1) 상호 배제 -> 임계 영역 내로 다수의 스레드가 진입을 막을 수 있는지를 검사.
(2) 공정성 -> 스레드들이 락 획득에 대한 공정한 기회가 주어지는지를 검사 -> 기아 상태가 발생하는지에 대해 검사
(3) 성능 -> 락 사용 시간적 오버헤드를 평가한다.

## 5. 인터럽트 제어

- 장점:
    - 단순함: 인터럽트를 비활성화하면 코드가 실행 중에 다른 쓰레드가 끼어들지 않음을 보장할 수 있다. 이 방법은 쉽게 이해하고 구현할 수 있다.
- 단점:
    - 특권 연산 필요: 인터럽트를 비활성화하려면 해당 쓰레드가 특권 연산을 실행할 수 있어야 하므로 신뢰할 수 있는 프로그램이어야 한다.
    - 탐욕적 기법 문제: 프로그램이 lock을 획득하고 CPU를 독점할 수 있으며, 악의적인 프로그램이 이를 악용할 수 있다.
    - 멀티프로세서 환경에서 효과 없음: 여러 프로세서에서 실행되는 쓰레드에 대해서는 한 프로세서에서의 인터럽트 비활성화가 다른 프로세서에 영향을 미치지 않아 임계 영역을 안전하게 보호할 수 없다.
    - 중요한 인터럽트 놓칠 위험: 장시간 인터럽트를 비활성화하면 중요한 시스템 인터럽트를 놓쳐 시스템 문제를 초래할 수 있다. 예를 들어, 저장 장치에서 읽기 요청을 마친 사실을 모르고 지나칠 수 있다.
    - 비효율성: 인터럽트를 비활성화하는 코드가 최신 CPU에서 더 느리게 실행되는 경향이 있다
