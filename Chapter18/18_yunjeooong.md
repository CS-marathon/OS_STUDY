
# 18장 페이징:개요

## 1. 페이징 탄생의 역사적 맥락

- **Atlas 시스템(1962)**: 최초 가상 메모리 설계. 세그멘테이션 기반이었으나 외부 단편화 한계 노출.
- **고정 크기 분할 제안**: 다양한 크기의 청크 대신 동일 크기 '페이지' 도입 
- **현대 OS 채택**: Atlas 개념 발전 → x86·ARM 등 모든 현대 CPU에서 하드웨어 지원.

> _“페이징은 가상 메모리의 ‘균질성’을 보장해, 동적 메모리 할당 관리의 복잡도를 획기적으로 낮춘다.”_


## 2. 세그멘테이션 vs 페이징: 외부/내부 단편화

| 구분                  | 세그멘테이션 (Segmentation)                | 페이징 (Paging)                                     |
| --------------------- | -------------------------------------------- | --------------------------------------------------- |
| **단위 크기**         | 가변 크기 (논리적 모듈 단위)                | 고정 크기 (일정한 페이지 크기)                       |
| **단편화 유형**       | 외부 단편화 (Heap·Stack 할당 시 구멍 생김)  | 내부 단편화 (페이지 내 남는 공간 발생 가능)          |
| **메모리 배치 과제**   | 복잡 → 첫-적합·최적-적합 알고리즘 필요       | 단순 → 빈 프레임 리스트에서 꺼내 할당               |
| **주소 변환 구조**     | 세그먼트 테이블 + 오프셋                    | 페이지 테이블 + 오프셋                               |

- **외부 단편화**: 큰 할당 요구 시 빈 블록 연결 어려움.
- **내부 단편화**: 페이지 크기의 절반 이하 낭비 가능성.


## 3. 간단한 예제 및 개요

### 3.1 가정

- 가상 주소 공간: **64B** (6비트 주소)
- 페이지 크기: **16B** → 4개 페이지 (VPN = 0~3)
- 물리 메모리: **128B** → 8개 프레임 (PFN = 0~7)

### 3.2 가상→물리 배치 예시

```
VPN 0 ─▶ PFN 3
VPN 1 ─▶ PFN 7
VPN 2 ─▶ PFN 5
VPN 3 ─▶ PFN 2
(프레임 0,1,4,6은 커널·비어 있음)
```

> 운영체제는 프로세스마다 위 **(VPN→PFN)** 매핑 정보를 **페이지 테이블**에 저장합니다.

### 3.3 실제 접근 시나리오

- 프로세스에서 `MOVL 21, %EAX` 실행 시:
    1. 가상 주소 **21(0b010101)** 분해
        - VPN = 0b01(1)
        - Offset = 0b0101(5)
    2. 페이지 테이블에서 **VPN=1** 항목 조회 → PFN=7
    3. 물리 주소 = `7 * 16 + 5 = 117` → 메모리 로드


## 4. 가상 주소 분할: VPN과 Offset

- 전체 비트 수 = `log2(가상 주소 공간 크기)`
- 페이지 크기 = `2^k` Byte → **오프셋 비트 = k**, **VPN 비트 = (전체 비트 - k)**

```
가상 주소 VA[5:0]
 ├─ VPN = VA[5:4]  (2비트)
 └─ Offset = VA[3:0] (4비트)
```

- 예: **VA=0b101011** → VPN=0b10(2), Offset=0b1011(11)


## 5. 페이지 테이블: 저장 위치 및 메모리 비용

### 5.1 메모리 오버헤드 계산

- 32bit 주소, 4KB 페이지 → **VPN=20bit, Offset=12bit**
- 배열 기반 선형 페이지 테이블 → **2^20 entries × 4B = 4MB**/프로세스
- 100개 프로세스 → 400MB 추가 메모리 요구

### 5.2 저장 위치

1. **PTBR(Page Table Base Register)**: 페이지 테이블 시작 물리 주소 저장
2. **메모리**: 전체 테이블은 MMU 내부에 두기 불가능 → 물리 메모리에 상주
3. **스왑**: 비활성 PTE는 디스크로 내보낼 수 있음


## 6. PTE(Page Table Entry) 상세 해부
| 필드         | 설명                                                                                           |
| ------------ | ---------------------------------------------------------------------------------------------- |
| **Valid (V)**   | 매핑 존재 여부 (0: 미할당 영역 접근 시 세그멘테이션 Fault)                                      |
| **Protection**  | 읽기(R), 쓰기(W), 실행(X) 허용 권한 비트                                                       |
| **Present (P)** | 메모리 상주 여부 (0: 스왑 아웃 → Page Fault 트랩)                                              |
| **Dirty (D)**   | 저장 후 수정 여부                                                                               |
| **Accessed (A)**| 최근 접근 여부 (교체 알고리즘의 히트 정보)                                                    |
| **PFN**         | 물리 프레임 번호(Physical Frame Number)                                                        |

<x86 아키텍처 예시>
```
|31           12|11|10|9|8|7|6 |5 |4 |3 |2 |1|0|
|  PFN(20bit) |D |A |G|PWT|PCD|U/S|R/W|P|
```


## 7. 가상→물리 주소 변환 절차와 수식

1. **VPN, Offset 분리**
    - `OFFSET_BITS = log2(PageSize)`
    - `VPN = (VA >> OFFSET_BITS)`
    - `Offset = VA & ((1 << OFFSET_BITS) - 1)`
2. **PTE 주소 계산**
    - `PTEAddr = PTBR + VPN * sizeof(PTE)`
3. **PTE 로드**
    - `PTE = MemoryLoad(PTEAddr)`
4. **Fault 검사**
    - `if (!PTE.Valid) Trap(SEGFAULT)`
    - `if (!checkPerm(PTE.Protection, accessType)) Trap(PROTFAULT)`
5. **물리 주소 생성**
    - `PA = (PTE.PFN << OFFSET_BITS) | Offset`
6. **데이터 접근**
    - `Data = MemoryLoad(PA)`

> **오버헤드**: 참조당 추가 메모리 접근 1회 → 전체 메모리 참조 2배 이상 증가


## 8. 메모리 트레이스: 루프당 접근 패턴 분석

```c
int array[1000];
for (i = 0; i < 1000; i++) {
    array[i] = 0;
}
```

| 동작             | 횟수/루프 | 페이지 변환(PT) | 실제 접근(메모리) | 합계 메모리 접근 |
| ---------------- | --------- | --------------- | ----------------- | ---------------- |
| 명령어 인출(4개) | 4         | 4               | 4                 | 8                |
| 데이터 저장(1개) | 1         | 1               | 1                 | 2                |
| **총합**         | —         | **5**           | **5**             | **10**           |

- **1000회 반복** → **10,000회** 페이지 테이블 접근 발생
- 메모리 대역폭 소모·지연 심화


## 9. 페이징 단점 극복을 위한 최적화 기법

1. **TLB (Translation Lookaside Buffer)**
    - 최근 사용된 PTE 캐시 → TLB Hit 시 페이지 테이블 접근 생략
2. **다단계 페이지 테이블**
    - 2~4단계 구조로 나눠 메모리 절약 (전체 테이블 로드 방지)
3. **역 페이지 테이블(Inverted PT)**
    - PFN→(PID, VPN)로 매핑 → 공유 페이지 관리 최적화
4. **Huge Pages (대형 페이지)**
    - 2MB/1GB 페이지 사용 → PTE 개수 감소, TLB 효율 상승


