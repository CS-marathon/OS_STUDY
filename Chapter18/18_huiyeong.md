# 페이징 개요

운영체제가 모든 공간 관리 문제를 해결할 때 사용하는 방식은 아래와 같다.

|구분	|가변 크기 분할 (Segmentation) |	고정 크기 분할 (Paging)
|-------------|----------------|--------|
|방식 |	공간을 다양한 크기의 조각으로 나눔 |		공간을 고정된 크기로 나눔
 |	특징 |		논리적 단위(코드, 힙, 스택 등) 기반 분할	 |	일정 크기의 페이지 단위로 분할
 |	장점 |		프로세스 구조에 맞춰 유연한 분할 가능 |		단편화 문제 감소, 관리가 단순함
 |	단점 |		단편화(fragmentation) 발생	 |	내부 단편화 가능성 존재
 |	대표 사례	 |	가상 메모리 세그멘테이션	 |	가상 메모리 페이징 (Atlas 시스템 등)

<br><br>

## 1. 페이징 개념
### (1) 페이징의 장점
- 유연성
: 프로세스의 주소 공간 사용 방식과는 상관없이 효율적으로 주소 공간 개념을 지원할 수 있다.<br>
- 빈 공간 관리의 단순함

### (2) 페이지 테이블이란
:주소 공간의 각 가상 페이지에 대한 물리 메모리 위치 기록을 위한 자료구조
주소 공간의 가상 페이지 주소 변환 정보를 저장하는 것이 주요 역할이다.

페이지 테이블은 프로세스 마다 존재한다.

### (3) 순서
<img width="209" alt="스크린샷 2025-04-27 오전 2 00 15" src="https://github.com/user-attachments/assets/2afe1f43-5b44-4719-be4b-a26d4a64f3dd" />

사진 출처 : 책 운영체제 아주 쉬운 세 가지 이야기

Va5는 가상 주소의 최상위 비트이며 Va0이 최하위 비트를 나타낸다.

상위 2비트 → VPN 가상 페이지 번호 (어느 가상 페이지?)<br>
하위 4비트 → Offset (그 페이지 안에서 어디?)

(예) 가상 주소가 21이라고 하자<br>
21 -> 이진수 010101<br>
01 = 가상 페이지 번호<br>
0101 = 5번째 바이트

즉, 가상페이지 1의 5번째 바이트이다.

<img width="318" alt="스크린샷 2025-04-27 오전 2 07 43" src="https://github.com/user-attachments/assets/93367def-b276-40d4-a3ad-e76bb3ec2ee1" />

사진 출처 : 책 운영체제 아주 쉬운 세 가지 이야기

페이지테이블에서 가상 페이지 1번의 물리 프레임 번호(PFN, physical frame number) 혹은 물리 페이지 번호(PPN, physical page number)는 7이다.
<br> 오프셋은 동일하다!

최종적인 물리 주소는 1110101(이진수) 이다.

<br><br>

## 2. 페이지 테이블은 어디에 저장되는가
페이지 테이블은 매우 커질 수 있다. (작은 세그멘트 테이블이나 베이스-바운드 쌍에 비해서)
### (1) 페이지 테이블은 왜 커질까?
32비트 가상 주소 공간을 예로 들어 보자.<br>
가상 주소는 20비트 VPN(가상 페이지 번호) + 12비트 오프셋으로 나뉜다.

20비트 VPN이란?<br>
변환의 개수가 2²⁰ = 약 100만 개의 페이지를 뜻한다.<br>
각 페이지마다 변환 정보를 저장하려면 페이지 테이블 항목(PTE)마다 **4바이트(PTE)**가 필요하다고 가정하면<br>
한 프로세스당 필요한 메모리는 4바이트 × 1백만 ≈ 4MB 이다.

### (2) 프로세스가 여러 개라면?
예를 들어 100개 프로세스가 동시에 실행 중이라면<br.
4MB × 100 = 400MB 필요하다.

단순히 주소 변환만을 위해 400MB를 쓰는 건 비정상적이다.

페이지 테이블이 매우 크기 때문에 현재 실행 중인 프로세스의 페이지 테이블을 저장할 수 있는 회로를 MMU(Memory Management Unit)안에 유지하지 않을 것이다.

### (3) 페이지 테이블은 어떻게 처리할까?
각 프로세스의 페이지 테이블은 운영체제가 관리하는 물리 메모리에 저장한다.

필요한 경우, <br>
운영체제 가상 메모리에 저장하거나, 디스크로 스왑할 수도 있다.

<br><br>

## 3. 페이지 테이블에는 실제 무엇이 있는가
### (1) 선형 페이지 테이믈
단순한 배열이다.

운영체제는 원하는 물리 프레임 번호를 찾기 위해서 가상 페이지 변호로 배열의 항목에 접근하고 그 항목의 페이지 테이블 항목을 검색한다.

### (2) 페이지 테이블 항목(PTE)의 비트
<img width="468" alt="스크린샷 2025-04-27 오전 2 45 58" src="https://github.com/user-attachments/assets/8e9c3ab2-278d-45c5-858f-c9585f5769b8" />

사진 출처 : 책 운영체제 아주 쉬운 세 가지 이야기

- Valid bit (V)<br>
목적: 특정 변환이 유효한지 여부를 나타냅니다.<br>
용도: 프로세스가 할당되지 않은 메모리 공간에 접근하려 할 때, 운영체제는 이를 "무효"로 표시하고 트랩을 발생시킵니다. 예를 들어, 스택과 힙 사이의 미사용 공간에 접근하면 오류가 발생합니다.

- Protection bit (R/W)<br>
목적: 페이지가 읽기/쓰기 가능한지를 표시합니다.<br>
용도: 이 비트에 따라 페이지에 대한 접근 방식(읽기, 쓰기, 실행 등)을 제어하고, 보호되지 않은 방식으로 접근하려고 하면 운영체제가 트랩을 발생시킵니다.

- Present bit (P)<br>
목적: 페이지가 물리 메모리에 있는지, 아니면 디스크에 있는지(스왑 아웃) 확인합니다.<br>
용도: 페이지가 물리 메모리에서 사라졌다면, 운영체제는 디스크에서 페이지를 불러오고 스왑 작업을 합니다.

- Dirty bit (D)<br>
목적: 메모리에 로드된 후, 페이지가 수정되었는지를 나타냅니다.<br>
용도: 페이지가 디스크로 스왑되기 전에, 수정된 데이터를 저장해야 할지 여부를 결정합니다.

- Reference bit (A)<br>
목적: 페이지가 접근되었는지 여부를 추적합니다.<br>
용도: 자주 사용되는 페이지를 메모리에 유지하고, 교체할 페이지를 결정하는 데 중요한 역할을 합니다.

- User/Supervisor bit (U/S)<br>
목적: 페이지에 대한 사용자 모드/커널 모드 접근을 구분합니다.<br>
용도: 사용자 프로그램이 시스템 자원에 접근할 수 없도록 제한합니다.

- Page Frame Number (PFN)<br>
목적: 페이지가 물리 메모리에서 저장된 프레임 번호를 나타냅니다.<br>
용도: 가상 주소를 물리 주소로 변환할 때 사용됩니다.

<br><br>

## 4. 페이징 : 너무 느림
(1) 현재 프로세스의 페이지 테이블 찾기<br>
CPU는 **페이지 테이블 베이스 레지스터(PTBR)**에 저장된 주소를 통해, 프로세스의 페이지 테이블 시작 위치를 알아낸다.<br>
(2)가상 페이지 번호(VPN) 계산<br>
가상 주소에서 상위 비트(VPN)를 추출한다.<br>
→ VPN = (VirtualAddress & VPN_MASK) >> SHIFT<br>
(3) 페이지 테이블 항목(PTE) 접근<br>
페이지 테이블 시작 주소(PTBR)에 VPN을 인덱스로 사용해 PTE 주소를 구한다.<br>
→ PTEAddr = PTBR + (VPN * sizeof(PTE)) <br>
이 주소에서 PTE를 메모리로부터 읽어온다.<br>
(4) PTE 확인<br>
Valid 비트 확인 → 무효면 SEGMENTATION FAULT 발생.<br>
Protection 비트 확인 → 접근 권한 없으면 PROTECTION FAULT 발생.<br>
(5) 물리 주소 계산<br>
PTE에서 PFN(Page Frame Number)을 얻는다.<br>
가상 주소의 오프셋과 결합해 최종 물리 주소를 만든다.<br>
→ PhysAddr = (PFN << SHIFT) | offset<br>
(6) 메모리 접근<br>
물리 주소(PhysAddr)에서 데이터를 읽어 레지스터에 저장한다.

<br>

-> 하드웨어와 소프트웨어의 신중한 설계 없이는 페이지 테이블로 인해 <br>
시스템이 매우 느려질 수 있으며 <br> 너무 많은 메모리를 차지한다.

