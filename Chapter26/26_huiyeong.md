# 병행성 : 개요
|항목|프로세스|스레드|	
|---|---|---|	
|주소 공간 |		독립적인 주소 공간 |	주소 공간을 공유 (스레드 간 메모리 공유) |	
|프로그램 카운터(PC) |		프로세스마다 하나의 PC가 존재	 |	각 스레드마다 독립적인 PC가 존재 |	
|문맥 교환	 | 전체 프로세스 상태를 PCB에 저장 |		TCB에 저장, 주소 공간은 그대로 사용 |
|레지스터 |		프로세스마다 레지스터 세트가 별도로 존재	 |	스레드마다 레지스터 세트가 존재 |	
|스택	 |	하나의 스택만 존재 (단일 스레드 프로세스) |		각 스레드마다 독립적인 스택이 존재 |	
|문맥 교환 비용 |		상대적으로 더 많은 비용이 발생 |		상대적으로 적은 비용 (주소 공간 공유 덕분) |	
|스레드-로컬 저장소	 |	없음 |		각 스레드마다 존재<br>스택에서 할당되는 변수들이나 매개변수, 리턴 값 등이 저장 |	
|실행	 |	하나의 프로세서에서 한 번에 하나의 명령어 실행	 |	여러 개의 스레드가 병렬로 실행 가능 (멀티스레드 환경) |	

<img width="420" alt="스크린샷 2025-05-01 오후 10 38 10" src="https://github.com/user-attachments/assets/c072d8d0-1242-4561-8038-35f8f34d0b7d" />

사진 출처 : 책 운영체제 아주 쉬운 세 가지 이야기

### 1. 스레드 생성
스레드 생성: 예를 들어, 하나의 프로그램에서 두 개의 스레드를 생성한다고 가정해봅시다. Thread 1은 "A"를 출력하고, Thread 2는 "B"를 출력하는 작업을 담당한다. <br>
이 두 스레드는 동시에 실행될 수 있지만, 어느 스레드가 먼저 실행될지는 스케줄러에 의해 결정된다. 

스레드 생성 함수가 호출되고 난 뒤, 두 스레드는 즉시 실행될 수도 있고, 나중에 실행될 수도 있다.

### 2. 실행 순서
스케줄러의 역할: Thread 1과 Thread 2의 실행 순서는 운영 체제의 스케줄러가 결정한다. <br>
예를 들어, Thread 1이 먼저 실행되었는지, 아니면 Thread 2가 먼저 실행되었는지 예측할 수 없다.

스케줄러는 CPU 시간을 각 스레드에 할당하고, 이 순서는 실행될 때마다 달라질 수 있다.

### 3. 경쟁 조건 (Race Condition)
경쟁 조건: 두 개의 스레드가 같은 자원에 동시에 접근할 때 문제가 발생할 수 있다. <br>
예를 들어, 두 스레드가 같은 변수를 변경하는 코드가 있다고 가정하자. <br>
스레드 1이 변수 x의 값을 1로 변경하는 동안, 스레드 2가 x의 값을 2로 변경하는 상황이 발생할 수 있다. 그 결과, 예상치 못한 값이 저장되거나 실행 순서에 따라 다른 값이 출력될 수 있다.

이렇게 명령어 실행 순서에 따라 결과가 달라지는 상황을 경쟁 조건이라고 한다.

### 4. 비결정적인 결과 vs 결정적인 결과
비결정적인 결과: 예를 들어, 두 개의 스레드가 같은 변수를 수정하고, 그 결과가 실행될 때마다 다르게 나올 수 있다. 이 경우는 결과가 예측할 수 없고 비결정적 결과라고 한다.  <br>
결정적인 결과: 항상 같은 결과가 나오는 프로그램이 설계된 경우이다. 예를 들어, 두 스레드가 서로 다른 변수를 수정한다면, 그 결과는 항상 동일하게 나올 것이다.

### 5. 임계 영역 (Critical Section)
임계 영역: 두 스레드가 공유 자원에 동시에 접근하려고 할 때, 이 코드 구역을 임계 영역이라고 부른다.  <br> 
상호 배제 (Mutual Exclusion): 임계 영역에 대한 접근을 한 번에 하나의 스레드만 허용하는 방식이다. 이렇게 하면 두 스레드가 동시에 공유 자원에 접근하는 것을 방지할 수 있다. <br>

### 6. 원자적 연산 (Atomic Operation)
원자성이란 작업이 "하나의 단위"로 실행되어, 중간에 다른 작업이 끼어들 수 없다는 의미이다. <br> 
예를 들어, memory−add와 같은 명령어는 원자적으로 실행되어, 중간에 인터럽트나 다른 쓰레드의 개입 없이 작업이 완료된다.  <br> 
이 방식은 인터럽트 발생 가능성을 원천적으로 차단하여, 하나의 연산이 실행되는 동안 다른 연산이 간섭할 수 없도록 보장한다.

예시: memory−add 0x8049a1c, $0x1 명령어는 메모리 상의 특정 주소에 값을 더하는 연산으로, 원자적으로 실행되므로 중간에 인터럽트가 발생해도 연산이 정상적으로 완료된다.

### 7. 복합적인 명령어
위와 같은 원자적 명령어는 단일 연산으로 여러 명령어를 하나로 묶어 실행할 수 있다.  <br> 
예를 들어, B-tree 같은 병행성 있는 데이터 구조를 다룰 때, 여러 명령어를 원자적으로 실행하려면 하드웨어적으로 지원되는 명령어가 필요하다. <br> 
하지만 대부분의 경우, 원자적으로 처리할 수 있는 명령어는 제한적이다.

### 8. 동기화 문제와 해결 방법
멀티 쓰레드 환경에서 여러 스레드가 동일한 자원을 접근할 때, **경쟁 조건 (Race Condition)**이 발생할 수 있다.  <br> 
이를 해결하기 위해서는 동기화 기법이 필요하며, 하드웨어에서 제공하는 동기화 명령어와 운영 체제의 지원을 통해, 하나의 스레드만 임계 영역에서 실행되도록 보장한다.

동기화 명령어는 각 스레드가 임계 영역에 접근하는 순서를 제어하여, 한 번에 하나의 스레드만 해당 영역을 실행하도록 한다.

### 9. 멀티 쓰레드 프로그램 작성
멀티 쓰레드 프로그램을 작성할 때 중요한 점은 임계 영역에서의 동기화이다. 
하드웨어의 동기화 명령어와 운영 체제의 지원을 통해, 각 스레드가 임계 영역에서 경쟁하지 않도록 **상호 배제(mutual exclusion)**를 구현할 수 있다. 
이를 통해 병행 실행에서 발생할 수 있는 오류를 방지하고, 제대로 작동하는 멀티 쓰레드 프로그램을 만들 수 있다.


