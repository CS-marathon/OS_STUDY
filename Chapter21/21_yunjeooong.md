# 20장 페이징: 더 작은 테이블 

선형 페이지 테이블은 **주소 공간 크기**에 비례하여 **거대한 메모리**를 차지합니다. 특히 32비트 주소 · 4KB 페이지 환경에서:

- VPN = 20 비트 → 2^20 entries
- PTE 크기 = 4B → **4MB**/프로세스 
- 프로세스 100개 → **400MB** 오버헤드!

**핵심 질문**: 페이지 테이블을 어떻게 **더 작게** 만들 수 있을까?

---

## 1. 간단한 해법: 더 큰 페이지 
- **페이지 크기 4KB → 16KB** (4배)
    - VPN 비트 20 → 18
    - 테이블 엔트리 2^18 → **1MB**로 감소
    - `테이블 크기 ∝ 1 / 페이지 크기`

> **장점**: 알고리즘·자료구조 미변경. 단순 설정만으로 효과적.

> **단점**: 내부 단편화 증가 → 작은 객체 낭비 커짐.

---

## 2. 하이브리드 접근: 페이징 + 세그멘트 

### 2.1 구조

1. **세그멘트별** 페이지 테이블 유지 → 코드·힙·스택마다 테이블
2. **레지스터** `Base[SN]`, `Limit[SN]` 으로 각 세그멘트 테이블 위치·크기 저장
3. 가상 주소 분해:
   ```text
   ┌─────────┬──────────┬─────────┐
   │ SN (2b) │ VPN (n)b │ Offset  │
   └─────────┴──────────┴─────────┘
   ```
4. **PTE 주소 계산**:
   ```pseudo
   SN       = (VA & SEG_MASK) >> SN_SHIFT
   VPN      = (VA & VPN_MASK) >> VPN_SHIFT
   AddrPTE  = Base[SN] + VPN * sizeof(PTE)
   ```

### 2.2 장·단점

- **장점**: 미사용 세그멘트 테이블은 할당 안 함 → 메모리 절약
- **단점**:
    - 여전히 외부 단편화(세그멘트 크기 가변)
    - 스택/힙처럼 sparsely used 영역 낭비 잔존
    - 위치/크기 관리 복잡

---

## 3. 멀티 레벨 페이지 테이블 

선형 테이블을 **트리**로 변환하여, **빈 구간은 할당 안 함**.

### 3.1 2단계 예시

- **PD (Page Directory)**: 각 PDE가 4KB 단위 페이지 테이블 존재 여부·위치 저장
- **PT (Page Table)**: 실제 PTE를 담은 메모리 페이지들만 할당

```pseudo
PDIndex = VPN >> PT_BITS
PDE     = Mem[PDBR + PDIndex * sizeof(PDE)]
if (!PDE.valid)  SIGSEGV
PTIndex = VPN & ((1<<PT_BITS)-1)
PTE     = Mem[(PDE.PFN<<SHIFT) + PTIndex*sizeof(PTE)]
```  
- `VPN = PDIndex | PTIndex`
- 3단계 이상 확장 가능

### 3.2 장·단점

- **장점**:
    - 실제 사용된 **주소 공간** 분량만큼만 페이지 디렉터리·테이블 할당
    - 메모리 조각화 최소화 → 개별 페이지 단위로 할당·해제
- **단점**:
    - TLB 미스 시 **2번** 메모리 접근 → 오버헤드 2배
    - 하드웨어·소프트웨어 구현 복잡도↑

---

## 4. 역 페이지 테이블 

- **아이디어**: 프로세스당 테이블 대신 **시스템 전체** 하나의 테이블 유지
- **항목**: 물리 프레임 → `(PID, VPN, prot, …)`
- **검색**: 해시 또는 체인 방식 → PFN → (PID, VPN) 역변환

**장점**: 총 테이블 크기 ∝ 물리 프레임 수 (작음)

**단점**: 해시 충돌·동기화·공유 페이지 처리 복잡

---

## 5. 페이지 테이블 디스크 스와핑

- 너무 큰 테이블도 **커널 가상 메모리** 상에서 스왑 가능
- 메모리 부족 시 페이지 테이블 자체를 **디스크**로 내보내고, 필요 시 다시 스왑인
- 사례: VAX/VMS 스왑 테이블 관리 citeturn2file0

---

## 6. 결론

1. **문제**: 거대 선형 테이블은 메모리 과다 사용
2. **해법**: 더 큰 페이지, 하이브리드, 멀티레벨, 역테이블, 스왑
3. **절충**: 시간–공간 트레이드오프를 워크로드·하드웨어 환경에 맞춰 선택
